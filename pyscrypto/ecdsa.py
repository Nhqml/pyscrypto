import math
from collections import namedtuple

import click
from termcolor import cprint


class Point(click.ParamType):
    name = "point"

    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

    def __str__(self):
        return f"({self.x}, {self.y})"

    def __repr__(self):
        return f"<Point {str(self)}>"

    def convert(self, value, param, ctx):
        if isinstance(value, Point):
            return value

        try:
            x, y = value.split(",", 1)

            x = x.lstrip("(")
            y = y.rstrip(")")

            return Point(int(x), int(y))
        except ValueError:
            self.fail(f"{value!r} is not a valid point", param, ctx)


POINT = Point()


INF_POINT = Point(math.inf, math.inf)


@click.group()
def ecdsa():
    """ECDSA (elliptic curves) functions"""
    pass


@ecdsa.command("calc-points")
@click.argument("generator", type=POINT)
@click.argument("a", type=int)
@click.argument("mod", type=int)
def calculate_points(generator: Point, a: int, mod: int):
    """Calculate all points generated by the GENERATOR.

    A comes directly from the elliptic curve equation (y² = x³ + ax + b)
    MOD is the modulo
    """
    points: list[Point] = [generator]

    cprint(
        f"Please remember that all operations are mod {mod}\n",
        color="red",
        attrs=["bold"],
    )
    cprint(f"P = {generator}\n", color="green")

    # nb_points < P ^ 2
    for i in range(2, mod**2):
        # Add P with (i - 1)P - dumb but works
        p = points[0]
        q = points[i - 2]

        cprint(f"P = {p} ; Q = {q}", color="yellow")

        if p != q:
            if q.x - p.x == 0:
                cprint("s = inf", attrs=["dark"])
                points.append(INF_POINT)
                cprint(f"{i}P = {INF_POINT}", color="cyan")
                break

            s = (q.y - p.y) % mod * pow(q.x - p.x, -1, mod)
            cprint("s = (y_q - y_p) / (x_q - x_p)", end=" ", attrs={"dark"})
            cprint(f"= ({q.y} - {p.y}) / ({q.x} - {p.x}) = {s}", attrs=["dark"])
        else:
            if p.y == 0:
                cprint("s = inf", color=["dark"])
                points.append(INF_POINT)
                cprint(f"{i}P = {INF_POINT}", color="cyan")
                break

            s = (3 * p.x**2 + a) % mod * pow(2 * p.y, -1, mod)
            cprint("s = (3 * x_p^2) / (2 * y_p)", end=" ", attrs=["dark"])
            cprint(f"= (3 * {p.x}^2) / (2 * {p.y}) = {s}", attrs=["dark"])

        t = (p.y - s * p.x) % mod
        cprint("t = y_p - s * x_p", end=" ", attrs=["dark"])
        cprint(f"= {p.y} - {s} * {p.x} = {t}", attrs=["dark"])

        xpq = (s**2 - p.x - q.x) % mod
        cprint("x_pq = s^2 - x_p * x_q", end=" ", attrs=["dark"])
        cprint(f"= {s}^2 - {p.x} * {q.x} = {xpq}", attrs=["dark"])

        ypq = (-s * xpq - t) % mod
        cprint("y_pq = -s * x_pq - t ", end=" ", attrs=["dark"])
        cprint(f"= {s}^2 - {p.x} * {q.x} = {xpq}", attrs=["dark"])

        p = Point(xpq, ypq)
        points.append(p)
        cprint(f"{i}P = {p}\n", color="cyan")

    return points
