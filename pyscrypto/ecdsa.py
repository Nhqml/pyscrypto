import itertools
import math
from contextlib import redirect_stdout
from os import devnull

import click
from termcolor import cprint


class Point(click.ParamType):
    name = "point"

    def __init__(self, x=0, y=0):
        self._x = x
        self._y = y

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

    def __hash__(self):
        return hash((self.x, self.y))

    def __str__(self):
        return f"({self.x}, {self.y})"

    def __repr__(self):
        return f"<Point {str(self)}>"

    @property
    def x(self):
        return self._x

    @property
    def y(self):
        return self._y

    def convert(self, value, param, ctx):
        if isinstance(value, Point):
            return value

        try:
            x, y = value.split(",", 1)

            x = x.lstrip("(")
            y = y.rstrip(")")

            return Point(int(x), int(y))
        except ValueError:
            self.fail(f"{value!r} is not a valid point", param, ctx)


POINT = Point()


INF_POINT = Point(math.inf, math.inf)


def generate_points(generator: Point, a: int, mod: int) -> list[Point]:
    points: list[Point] = [generator]

    cprint(
        f"Please remember that all operations are mod {mod}\n",
        color="red",
        attrs=["bold"],
    )
    cprint(f"P = {generator}\n", color="green")

    # nb_points < P ^ 2
    for i in range(2, mod**2):
        # Add P with (i - 1)P - dumb but works
        p = points[0]
        q = points[i - 2]

        cprint(f"P = {p} ; Q = {q}", color="yellow")

        if p != q:
            if q.x - p.x == 0:
                cprint("s = inf", attrs=["dark"])
                points.append(INF_POINT)
                cprint(f"{i}P = {INF_POINT}", color="cyan")
                break

            s = (q.y - p.y) % mod * pow(q.x - p.x, -1, mod)
            cprint("s = (y_q - y_p) / (x_q - x_p)", end=" ", attrs={"dark"})
            cprint(f"= ({q.y} - {p.y}) / ({q.x} - {p.x}) = {s}", attrs=["dark"])
        else:
            if p.y == 0:
                cprint("s = inf", color=["dark"])
                points.append(INF_POINT)
                cprint(f"{i}P = {INF_POINT}", color="cyan")
                break

            s = (3 * p.x**2 + a) % mod * pow(2 * p.y, -1, mod)
            cprint("s = (3 * x_p^2) / (2 * y_p)", end=" ", attrs=["dark"])
            cprint(f"= (3 * {p.x}^2) / (2 * {p.y}) = {s}", attrs=["dark"])

        t = (p.y - s * p.x) % mod
        cprint("t = y_p - s * x_p", end=" ", attrs=["dark"])
        cprint(f"= {p.y} - {s} * {p.x} = {t}", attrs=["dark"])

        xpq = (s**2 - p.x - q.x) % mod
        cprint("x_pq = s^2 - x_p * x_q", end=" ", attrs=["dark"])
        cprint(f"= {s}^2 - {p.x} * {q.x} = {xpq}", attrs=["dark"])

        ypq = (-s * xpq - t) % mod
        cprint("y_pq = -s * x_pq - t ", end=" ", attrs=["dark"])
        cprint(f"= {s}^2 - {p.x} * {q.x} = {xpq}", attrs=["dark"])

        p = Point(xpq, ypq)
        points.append(p)
        cprint(f"{i}P = {p}\n", color="cyan")

    return points


@click.group()
def ecdsa():
    """ECDSA (elliptic curves) functions"""
    pass


@ecdsa.command()
@click.argument("generator", type=POINT)
@click.argument("a", type=int)
@click.argument("mod", type=int)
def gen_points(generator: Point, a: int, mod: int):
    """Calculates all points generated by the GENERATOR.

    \b
    A comes directly from the elliptic curve equation (y² = x³ + ax + b)
    MOD is the modulo
    """
    generate_points(generator, a, mod)


@ecdsa.command()
@click.argument("point", type=POINT)
@click.argument("a", type=int)
@click.argument("b", type=int)
@click.argument("mod", type=int)
def check_generator(point: Point, a: int, b: int, mod: int):
    """Checks that the given point is a generator.

    \b
    A and B come directly from the elliptic curve equation (y² = x³ + ax + b)
    MOD is the modulo
    """

    curve_points = [
        p
        for p in map(lambda t: Point(*t), itertools.product(range(mod), repeat=2))
        if (p.y**2) % mod == (p.x**3 + a * p.x + b) % mod
    ]

    with open(devnull, "w") as f, redirect_stdout(f):
        generated_points = generate_points(point, a, mod)

    if set(curve_points) <= set(generated_points):
        cprint(f"{point} is a generator!", color="green", attrs=["bold"])
    else:
        cprint(f"{point} is a not generator!", color="red", attrs=["bold"])
